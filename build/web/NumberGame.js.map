{"version":3,"file":"NumberGame.js","sources":["../../../../../kds/src/commonMain/kotlin/com/soywiz/kds/Array2.kt","arrayUtils.kt","generated/_Collections.kt","collections/Collections.kt","../../../../../kds/src/commonMain/kotlin/com/soywiz/kds/_Delegates.kt","../../../../../korge/src/commonMain/kotlin/com/soywiz/korge/input/MouseEvents.kt","../../../../../korge/src/commonMain/kotlin/com/soywiz/korge/ui/TextButton.kt","../../../../../korge/src/commonMain/kotlin/com/soywiz/korge/view/Text.kt","kotlin/math.kt","../../../../../korge/src/commonMain/kotlin/com/soywiz/korge/view/Container.kt","../../../../../korge/src/commonMain/kotlin/com/soywiz/korge/view/SolidRect.kt","../../../../../src/commonMain/kotlin/Board.kt","util/Standard.kt","../../../../../korma/src/commonMain/kotlin/com/soywiz/korma/geom/ds/Array2Ext.kt","../../../../../src/commonMain/kotlin/BoardMediator.kt","../../../../../src/commonMain/kotlin/main.kt","../../../../../src/commonMain/kotlin/Solver.kt","../../../../../src/commonMain/kotlin/Utils.kt"],"sourcesContent":[null,null,"/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element. Returns null if the collection is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value. Returns null if the list is empty.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.scanReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scanReduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic inline fun <S, T : S> Iterable<T>.scanReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:UseExperimental(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return ArrayList<E>().apply(builderAction)\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    checkBuilderCapacity(capacity)\n    return ArrayList<E>(capacity).apply(builderAction)\n}\n\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n",null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n",null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n",null,null,null,null,null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBAkBQ,e;gBCLR,K;mBC6hDA,oC;2BAAA,oD;uBC/5CA,gD;yBAvDA,+C;gCD0vCA,yD;;;;;;;;;YEl0CQ,M;iBAUA,oD;+BC4VR,6B;kBATA,iE;0BAAA,kH;;;;;;;;;;;;;;;0BCxVA,sE;0BAAA,sE;wBAAA,uD;cAAA,4D;gBCNA,wF;cAAA,oD;aAAA,mD;eCkWA,I;uBClWA,wD;uBCFA,wD;;;;;;;;;;;2CRg0DA,wD;;;;;;;;;;;sBA5kDA,+C;2BAg0CA,oD;;;;;;;;;;;ESrjDA,kC;IAAA,e;IAAA,iB;IAAA,uB;G;EAAA,gC;IAAA,mC;K;IAAuB,0D;IAAU,oD;IAAO,sD;IAAQ,kD;G;;EAAzB,0C;IAAA,sB;IAAA,kC;G;;EAAU,uC;IAAA,sB;IAAA,+B;G;;EAAO,wC;IAAA,sB;IAAA,gC;G;;EAAQ,sC;IAAA,sB;IAAA,8B;G;;;;;;EAAhD,4B;IAAA,sI;G;;EAAA,iC;IAAA,a;MAAA,gB;QAAA,uC;MAAA,a;QAAA,oC;MAAA,c;QAAA,qC;MAAA,Y;QAAA,mC;MAAA,QAAA,8C;;G;;EAKW,yC;IAAC,qB;MAAA,QAAiB,C;IAAG,sB;MAAA,SAAkB,C;IAAG,yB;MAAA,YAAgC,I;IAAzE,kB;IAAoB,oB;IAAqB,4B;IAAwC,2BAAe,iB;IAsDxG,wBAA6B,Y;IAC7B,4BAAiC,Y;IACjC,uBAA4B,Y;IAEN,cAAO,U;IAAP,eAAc,W;IXpDA,Q;ICLmB,YAAa,QDKrB,qBAAQ,QAAR,CCLqB,C;IAIvD,U;IAAA,SAAA,KAAM,OAAN,GAAa,CAAb,I;IAAb,aAAU,CAAV,mB;MACI,MAAM,CAAN,IUoD0C,cAAO,aAAP,GAAsB,gB;;IAApE,iBXpDQ,WAAa,OAAb,EAAoB,QAApB,EAA4B,sBCE7B,KDF6B,qBAA5B,C;IWqDI,cAAO,U;IAAP,eAAc,W;IXrDU,U;ICLmB,cAAa,QDKrB,qBAAQ,QAAR,CCLqB,C;IAIvD,Y;IAAA,WAAA,OAAM,OAAN,GAAa,CAAb,I;IAAb,eAAU,CAAV,yB;MACI,QAAM,GAAN,IUqDgC,qBVrDhB,GUqDqB,GAAK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AA,Q;IR5IpB,YAAc,cAAO,M;IACrB,OAAmB,eAAM,Y;IAEkD,oBAAZ,MAA5D,qCAJgB,IAIhB,EAAwC,SAAxC,EAAsD,IAAtD,CAA4D,EKiE5D,aLjE4D,C;IADnB,WKkEzC,e;IGwEA,iBHvEO,a;IGwEU,a;IAAA,U;IR7IpB,YAAc,cAAO,M;IACrB,SAAmB,eAAM,Y;IAEkD,oBAAZ,MAA5D,8BQ0IsB,GR1ItB,EAJgB,IAIhB,EAAwC,SAAxC,EAAsD,MAAtD,CAA4D,EKiE5D,aLjE4D,C;IQ2IxD,mBH1EJ,aG0EI,cAA+B,IAA/B,C;IVmN4E,8CAAa,uB;aAAa,iB;KAA1B,C;IAJhF,Q;IAAA,YOzRA,aPyRA,qBOzRA,aPyRA,kB;MAAiC,cAAW,aAAI,mCU9MpC,8DV8MoC,CAAJ,C;KUhN5C,iBHxEO,a;IG+ES,WAAK,OAAO,QAAP,C;IAAL,a;IAAA,U;IRpJnB,YAAc,cAAO,M;IACrB,SAAmB,eAAM,Y;IAEkD,oBAAZ,MAA5D,8BAAK,IAAL,EAJgB,IAIhB,EAAwC,SAAxC,EAAsD,MAAtD,CAA4D,EKiE5D,aLjE4D,C;IQkJxD,mBHjFJ,aGiFI,cAA+B,IAA/B,C;IACA,2BAAY,qDHlFhB,aGkFgB,CAAZ,C;IAFJ,gBH/EO,a;IGqFP,a;IAAA,U;IR1JH,YAAc,cAAO,M;IACrB,SAAmB,eAAM,Y;IAEkD,oBAAZ,MAA5D,8BQuJK,GRvJL,EAJgB,IAIhB,EAAwC,SAAxC,EAAsD,MAAtD,CAA4D,EKiE5D,aLjE4D,C;IQwJxD,mBHvFJ,aGuFI,aAA8B,IAA9B,C;IVsM4E,gDAAa,uB;aAAa,iB;KAA1B,C;IAJhF,U;IAAA,cOzRA,aPyRA,qBOzRA,aPyRA,kB;MAAiC,kBAAW,aAAI,qCUjMpC,gEViMoC,CAAJ,C;KU5LxC,QH7FJ,CACO,aADP,C;IGoEA,OHnEO,a;G;EI3EX,kB;IAAA,sB;G;EACI,yC;IAAA,e;IAAA,iB;IAAA,uB;G;EAAA,uC;IAAA,0C;K;IAAuB,gE;IAAM,kE;IAAO,gE;G;;EAAb,6C;IAAA,6B;IAAA,qC;G;;EAAM,8C;IAAA,6B;IAAA,sC;G;;EAAO,6C;IAAA,6B;IAAA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,W;YAAb,OAAa,cAAb,C;cAAa,sB;cACT,WAAY,WAAc,IcvzCQ,MduzCtB,C;;;YcvzCZ,UAAU,6BdwzCP,WcxzCO,EAAiC,iBAAjC,C;Yd2gDE,kBc1gDR,IAAJ,GAAI,EAAI,eAAJ,Cd0gDQ,W;YAAhB,gB;;;;;YAAA,KAAgB,yBAAhB,C;cAAA,gB;;;YAAgB,oC;YczgDR,IdygDqB,OczgDd,OAAO,MAAV,qCAAJ,C;cACI,IdwgDiB,OcxgDV,MAAH,wCAAJ,C;gBdwgDiB,OcvgDV,OAAO,O;gBACV,gB;gCAAA,+BAAO,gCdsgDM,OctgDO,OAAO,IAApB,CAAP,O;oBAAA,qC;yBAAA,mB;gBAAA,Q;;gBACG,IdqgDU,OcrgDH,MAAH,yCAAJ,C;kBdqgDU,OcpgDV,OAAO,Q;kBACV,gB;kCAAA,+BAAO,gCdmgDM,OcngDO,OAAO,IAApB,CAAP,O;sBAAA,qC;2BAAA,mB;kBAAA,Q;;kBAFG,gB;;;;;cAJX,gB;;;;;YAIW,gB;;;YAHP,gB;;;YAAA,gB;;;YADJ,gB;;;YdygDR,gB;;;;;;;;;;;;;;;;;Ec//CA,C;kCAjBA,wE;mBAAA,mF;QAAA,S;aAAA,Q;;aAAA,uB;EAiBA,C;EA4CwD,4C;IAAE,kD;EAAsB,C;EAMxB,8C;IAAE,kD;EAAsB,C;EAIvB,sD;IAAW,8C;EAAyB,C;uCApD7F,wB;IAKa,c;;Mdw4CG,Q;MADhB,IAAI,ccv4CI,Idu4CJ,iBcv4CI,Idu4CkB,UAA1B,C;QAAqC,aAAO,I;QAAP,e;OACrB,Ocx4CR,Idw4CQ,W;MAAhB,OAAgB,cAAhB,C;QAAgB,yB;QAAM,IAAI,EAAW,Ocx4ClB,qCdw4CO,CAAJ,C;UAAyB,aAAO,K;UAAP,e;;MAC/C,aAAO,I;;;Icz4CH,e;Md8tCG,kBAAM,eAAa,wBc9tC4B,Id8tC5B,EAAwB,EAAxB,CAAb,C;MAqEA,U;MAAA,ScnyCyC,IdmyCzC,W;MAAb,OAAa,gBAAb,C;QAAa,wB;qBACT,W;QAAgB,oB;QcnyCZ,IdmyCsB,IcnyClB,kCAAJ,C;UAAA,uD;;UAAA,sD;;QdmyCQ,YAAZ,WAAY,mB;;McpyC+B,OdqyCxC,W;Kc5xCc,aAAL,IAAK,K;Id+5DL,U;IADhB,UAAe,C;IACC,Sc/5DY,Md+5DZ,W;IAAhB,OAAgB,gBAAhB,C;MAAgB,6B;MACZ,YAAgB,Sch6D0B,Mdg6D1C,I;;Ich6DA,YAAY,Sdk6DT,Gcl6DS,I;IAEZ,qBAAqB,QAA0B,cAAjB,MAAO,KAAP,GAAc,CAAd,IAAiB,EAAc,CAAd,CAA1B,I;IACrB,yBAAyB,MAAO,KAAP,GAAc,CAAd,I;IAEzB,IAAI,mBAAkB,CAAtB,C;MbkBJ,WAAW,eahBkB,kBbgBlB,C;MSFX,iBAAc,CAAd,UId6B,kBJc7B,U;QTG6B,eajBsB,CbiBtB,C;;MajBrB,OAAO,gBbkBR,IalBQ,EAAyC,MAAzC,C;WACJ,IAAI,uBAAsB,CAA1B,C;MbeX,aAAW,eabkB,kBbalB,C;MSFX,mBAAc,CAAd,YIX6B,kBJW7B,Y;QTG6B,gC;;MadrB,OAAO,gBbeR,MafQ,EAAsD,MAAtD,C;KAGX,4BAA4B,UAAU,cAAV,EAA0B,kBAA1B,C;IdwsCzB,oBAAM,eAAa,wBctsCf,qBdssCe,EAAwB,EAAxB,CAAb,C;IAqEA,U;IAAA,Sc3wCF,qBd2wCE,W;IAAb,OAAa,gBAAb,C;MAAa,0B;mBACT,a;Mc3wCyB,gBAArB,gBd2wCsB,Mc3wCtB,S;MACI,OJhDN,SIgDqB,KAAR,KAAqB,SAA5B,EAAkC,yCAAlC,C;Md0wCI,YAAZ,aAAY,EUzzCT,SVyzCS,C;;IA1tBT,oBAAS,kB;IA6EA,U;IAAA,SA8oBT,aA9oBS,W;gBAAhB,OAAgB,gBAAhB,C;MAAgB,6B;McznBe,kBAAV,IdynBe,ScznBf,O;MAAU,gB;;Qd02Cf,U;QADhB,IAAI,0CAAsB,qBAA1B,C;UAAqC,eAAO,I;UAAP,e;SACrB,+B;QAAhB,OAAgB,gBAAhB,C;UAAgB,6B;UAAM,IAAI,EAAW,Scz2CtB,OAAH,0Cdy2CyB,Scx2CX,MAAH,6Cdw2Cc,Scx2CoB,OAAH,iCAA/B,Idw2Cc,Scx2CmD,OAAH,mCADzE,Mdy2CyB,Scv2CX,MAAH,6Cdu2Cc,Scv2CoB,OAAH,qCdu2CjB,Scv2CmD,OAAH,mCAA9D,CAFX,Cdy2Cc,CAAJ,C;YAAyB,eAAO,K;YAAP,e;;QAC/C,eAAO,I;;;MAlvBe,iB;QAAwB,aAAY,WAAI,SAAJ,C;;IA7EnD,oBAAS,kB;IA6EA,U;IAAA,SACT,aADS,W;gBAAhB,OAAgB,gBAAhB,C;MAAgB,6B;MclnBR,aAA0B,sBdknBE,SclnBF,EAAsB,8BAAtB,C;MAC1B,OAAc,WAAP,KAAe,MAAO,KAA7B,EAAmC,yDAAnC,C;MACmB,kBAAZ,YAAI,MAAJ,C;MdmiBR,oBAAS,kB;MA6EA,U;MAAA,+B;MAAhB,OAAgB,gBAAhB,C;QAAgB,6B;QAAM,IAAc,SchnBG,MAAM,SdgnBvB,C;UAAwB,aAAY,WAAI,SAAJ,C;;MchnBF,gB;;Qdi2CxC,W;QADhB,IAAI,cA/uBG,aA+uBH,iBA/uBG,aA+uBmB,UAA1B,C;UAAqC,eAAO,I;UAAP,e;SACrB,UAhvBT,aAgvBS,W;QAAhB,OAAgB,iBAAhB,C;UAAgB,8B;Uch2CJ,W;Udg2CU,IAAI,Ech2Cd,yBdg2CyB,Sch2CtB,MAAM,MAAT,4Bdg2CyB,Sch2CF,OAAvB,Qdg2Cc,CAAJ,C;YAAyB,eAAO,K;YAAP,e;;QAC/C,eAAO,I;;;MAlvBe,iB;QAAwB,aAAY,WAAI,SAAJ,C;;IA7EnD,oBAAS,kB;IA6EA,W;IAAA,UACT,aADS,W;gBAAhB,OAAgB,iBAAhB,C;MAAgB,8B;Mc5mBR,eAA0B,sBd4mBE,Sc5mBF,EAAsB,gCAAtB,C;MAGP,kBAAZ,YAAI,QAAJ,C;Md4hBR,oBAAS,kB;MA6EA,W;MAAA,gC;MAAhB,OAAgB,iBAAhB,C;QAAgB,8B;QAAM,IczmBc,CdymBA,SczmBI,MAAM,SdymBxB,C;UAAwB,aAAY,WAAI,SAAJ,C;;MczmBD,gB;;Qd01CzC,W;QADhB,IAAI,cA/uBG,aA+uBH,iBA/uBG,aA+uBmB,UAA1B,C;UAAqC,eAAO,I;UAAP,e;SACrB,UAhvBT,aAgvBS,W;QAAhB,OAAgB,iBAAhB,C;UAAgB,8B;UAAM,IAAI,Ccz1Cd,Qdy1CyB,Scz1CtB,OAAH,EAAkB,gBdy1CO,Scz1CM,OAAO,MAApB,EAA2B,qCAA3B,CAAlB,Cdy1CU,C;YAAyB,eAAO,K;YAAP,e;;QAC/C,eAAO,I;;;MAlvBe,iB;QAAwB,aAAY,WAAI,SAAJ,C;;IAikC1D,eAhkCO,aAgkCa,W;IACpB,IAAI,CAAC,QAAS,UAAd,C;MAAyB,MAAM,mCAA8B,oCAA9B,C;IAC/B,kBAAqB,QAAS,O;IAC9B,OAAO,QAAS,UAAhB,C;MczqDsB,kBAAV,Id0qDgB,Wc1qDhB,Ed0qD6B,QAAS,Oc1qDtC,C;Md4qCL,oBAAM,eAAa,qCAAwB,EAAxB,CAAb,C;MAqEA,W;MAAA,gC;MAAb,OAAa,iBAAb,C;QAAa,2B;sBACT,a;QAAgB,sB;QcjvCR,IdivCkB,McjvCX,MAAH,KdivCc,McjvCC,OAAnB,C;UAAA,qBdivCkB,MchvCX,M;;UADP,wD;;QdivCI,aAAZ,aAAY,qB;;MAwbZ,cAvbG,a;;Ic7wCH,OdssDG,W;EcpqDP,C;EAEgG,8H;IAAA,wC;IAAA,6B;IAAA,yB;IAAA,kD;IAAA,oD;IAAA,4B;IAAA,6B;IAAA,kC;EAYhG,C;;;;;;;;wDAZgG,Y;;;;;kCAC7E,4BAAU,W;mCACT,6BAAW,W;YAC3B,gB;;;;;YAAA,KAAO,mBAAS,UAAhB,KAA6B,oBAAU,UAAvC,C;cAAA,gB;;;YACa,WAAK,mBAAS,O;YbhC/B,WAAW,eAduE,IAcvE,C;YSFX,iBAAc,CAAd,UTZkF,ISYlF,U;cTG6B,mD;;;Ya+BrB,gB;4BAAA,sCb9BD,Ia8BC,O;gBAAA,qC;qBAAA,mB;YAAA,Q;;YACS,aAAK,oBAAU,OAAO,M;YbjCvC,aAAW,eAduE,MAcvE,C;YSFX,mBAAc,CAAd,YTZkF,MSYlF,Y;cTG6B,sD;;;YagCrB,gB;4BAAA,sCb/BD,Ma+BC,O;gBAAA,qC;qBAAA,mB;YAAA,Q;;YACA,IAAI,oBAAU,UAAd,C;cAAyB,gB;8BAAA,2E;kBAAA,qC;uBAAA,mB;cAAA,Q;;cAAzB,gB;;;;;YAAA,gB;;;YAHJ,gB;;;YAKA,OAAO,CAAC,oBAAU,UAAlB,EAA6B,qCAA7B,C;YACA,OAAO,mBAAS,UAAhB,EAA2B,wCAA3B,C;YACS,aAAK,mBAAS,O;YbtC3B,aAAW,eAduE,MAcvE,C;YSFX,mBAAc,CAAd,YTZkF,MSYlF,Y;cTG6B,qD;;;YaqCzB,gB;4BAAA,sCbpCG,MaoCH,O;gBAAA,qC;qBAAA,mB;YAAA,Q;;YATA,OAUA,OAAO,CAAC,mBAAS,UAAjB,EAA4B,sDAA5B,CAVA,M;;;;;;;;;;;;;;EAWJ,C;EAZgG,2E;IAAA,yD;qBAAA,kH;UAAA,S;eAAA,Q;;eAAA,uB;IAYhG,C;G;gCAZA,iC;IAAuF,OAYrF,OAZqF,SAAS,6CAAT,CAYrF,C;G;;;;;;;EAvLN,8B;IAAA,6B;MAAA,Y;KAAA,sB;G;2DCNA,yB;IAAA,yE;IjBgBQ,8B;ICLR,mB;IgBXA,uC;MAIW,YAAO,e;MAAP,aAAc,gB;MjBae,Q;MCLmB,YAAa,QDKrB,mBAAQ,MAAR,CCLqB,C;MAIvD,U;MAAA,SAAA,KAAM,OAAN,GAAa,CAAb,I;MAAb,aAAU,CAAV,mB;QACI,MAAM,CAAN,IgBb2B,UAAU,sBhBarB,CgBbyB,GAAK,eAAT,EhBarB,CgBbqC,GAAK,eAAL,IAAhB,CAAV,C;;MAA/B,OjBaQ,WAAa,KAAb,EAAoB,MAApB,EAA4B,sBCE7B,KDF6B,qBAA5B,C;IiBZZ,C;GALA,C;EAOA,+B;IAA0B,uB;MAAA,UAAgB,I;IACtC,IAAI,CAAC,IAAL,C;MAAW,MAAM,oBAAe,OAAf,C;EACrB,C;EAEA,6B;IACI,OAAqB,MAAT,SAAL,SAAK,CAAS,EAAM,MAAC,iBAAM,eAAN,CAAD,EAAqB,YAAC,MAAM,CAAN,IAAD,EAAY,eAAZ,CAArB,CAAN,C;EACzB,C;EAEA,6B;IACgB,oBAAL,SAAK,C;IAAgC,kBAAhB,SAAQ,gBAAR,C;Ifm0CrB,kBAAM,eAAa,qCAAwB,EAAxB,CAAb,C;IAqEA,U;IAAA,+B;IAAb,OAAa,gBAAb,C;MAAa,wB;MACT,WAAY,Wez4CkC,Yfy4CpB,Iez4CoB,EAAK,eAAL,Wfy4ClC,C;;Iez4ChB,OAAqB,cf04Cd,We14Cc,C;EACzB,C;EAEA,mC;IACkB,mB;MAAA,MAAW,C;IfmiDT,Q;IADhB,kBeliD+C,C;IfmiD/B,QeniDe,kBAAK,SAAL,CfmiDf,Y;IAAhB,OAAgB,cAAhB,C;MAAgB,yB;MAAM,celiDtB,YfkiD8C,WeliD9C,EfkiD2D,OeliD3D,C;;IAD8B,OfoiDvB,W;G;EehiDX,gC;IAEI,WAAe,QAAO,YAAO,CAAP,IAAP,CAAJ,GAAqB,YAAO,GAAP,IAArB,GAAqC,G;IAChD,UAAU,YAAO,IAAP,I;IACV,OAAY,UAAL,SAAK,EAAU,OAAO,CAAP,IAAV,CAAL,GAA+B,UAAJ,GAAI,CAA/B,I;EACX,C;EAOI,mD;IAIoB,UAAQ,M;IAHxB,IAAI,MAAK,CAAT,C;MAAY,OAAO,OAAO,WAAP,C;IACnB,IAAI,MAAK,CAAT,C;MAAkC,gBAAT,SAAN,KAAM,C;Mf6yCtB,kBAAM,eAAa,mCAAwB,EAAxB,CAAb,C;MAqEA,U;MAAA,6B;MAAb,OAAa,gBAAb,C;QAAa,wB;QACT,WAAY,Wen3C4B,Ofm3Cd,Ien3Cc,Cfm3C5B,C;;Men3CA,Ofo3CT,W;Ken3CH,UdiDgD,kB;IchDhC,OAAN,KAAM,M;IAAQ,SAAA,KAAM,KAAN,IAAc,CAAd,GAAkB,CAAlB,K;IAAxB,oC;MACqD,kBAAtC,gCAAU,aAAC,IAAI,CAAJ,IAAD,EAAS,KAAM,KAAf,CAAV,EAA+B,IAAI,CAAJ,IAA/B,C;Mf0yCZ,oBAAM,eAAa,qCAAwB,EAAxB,CAAb,C;MAqEA,U;MAAA,+B;MAAb,OAAa,gBAAb,C;QAAa,0B;qBACT,a;Qe/2C2B,kBAAhB,cf+2Ce,Me/2Cf,C;QLsCf,WKrCgB,aAAI,CAAJ,I;Qf82CA,YAAZ,aAAY,EUx0CT,WVw0CS,C;;Meh3CR,Wfi3CD,a;Me52CC,GAAI,gBAAO,IAAP,C;;IAER,OAAO,G;EACX,C;EAlBJ,qC;IAKI,+C;IAcA,OAAO,UAAU,SAAQ,CAAR,CAAV,EAAqB,CAArB,C;EACX,C;EAEA,yB;IAII,eAAe,IAAI,CAAJ,I;IACf,YAAY,IAAI,QAAJ,I;IACkC,gBAAvC,sBAAsB,KAAtB,EAA6B,QAA7B,C;IfwxCA,kBAAM,eAAa,mCAAwB,EAAxB,CAAb,C;IAqEA,Q;IAAA,2B;IAAb,OAAa,cAAb,C;MAAa,sB;mBACT,W;Me71CA,Ud4BgD,kB;Mc3BhD,aAAU,CAAV,a;QAG+C,YAAU,IAAI,CAAJ,I;QAArD,YAAY,CAAa,CfgMtB,IAAS,CAAT,IehMsB,CfgMR,IAAS,cAypCJ,IAzpCI,CehMd,Gfy1CU,IAzpCe,aehMZ,CfgMY,CehMzB,afgMT,SAAS,CAAT,IAAc,SAAS,cAypCJ,IAzpCI,CehMd,Gfy1CU,IAzpCe,aAAI,KAAJ,CehMzB,GAAkD,EAAlD,IAAyD,CAAzD,I;QACZ,GAAI,WAAI,KAAJ,C;;Mfw1CI,YAAZ,WAAY,Eet1CZ,Gfs1CY,C;;Ie91ChB,Of+1CO,W;Eer1CX,C;EAK2E,kI;IAAA,wC;IAAA,6B;IAAA,yB;IAAA,kD;IAAA,0D;IAAA,wB;IAAA,+B;IAAA,oC;IAAA,kC;EAU3E,C;;;;;;;;yDAV2E,Y;;;;;YACvD,gD;qCAAK,C;Yf4+CL,sC;YAAhB,gB;;;;;YAAA,KAAgB,yBAAhB,C;cAAA,gB;;;YAAgB,oC;YAAoB,UAAU,sB;Ye3+C1C,IAAI,6Bf2+CmD,Oe3+CnD,CAAJ,C;cAAA,8BACI,MAAM,CAAN,I;cADJ,gB;;;cAGI,IAAI,QAAO,CAAX,C;gBAAc,gB;gCAAA,iCAAM,GAAN,O;oBAAA,qC;yBAAA,mB;gBAAA,Q;;gBAAd,gB;;;;;;YAAA,gB;;;YAHJ,8BAII,C;YAJJ,gB;;;Yf2+CkB,oD;YAAtB,gB;;;Ye5+CA,gBf6+CO,sB;Yer+CP,IAAI,cAAa,CAAjB,C;cAAoB,gB;8BAAA,iCAAM,SAAN,O;kBAAA,qC;uBAAA,mB;cAAA,Q;;cAApB,gB;;;;;YARA,W;;YASJ,W;;;;;;;;;;;;;;EAAA,C;EAV2E,+E;IAAA,yD;qBAAA,sH;UAAA,S;eAAA,Q;;eAAA,uB;IAU3E,C;G;EAbA,gD;IAGkE,OAUhE,OAVgE,SAAS,6CAAT,CAUhE,C;G;EAK8E,4I;IAAA,wC;IAAA,6B;IAAA,yB;IAAA,kD;IAAA,oE;IAAA,wB;IAAA,yB;IAAA,+B;IAAA,qB;IAAA,oC;IAAA,kC;EAWhF,C;;;;;;;;8DAXgF,Y;;;;;YAC5D,qD;YAAA,cAAY,SAAQ,CAAR,C;;+Bfw+ChB,C;qCACM,O;YACF,sC;YAAhB,gB;;;;;YAAA,KAAgB,yBAAhB,C;cAAA,gB;;;YAAgB,oC;Ye1+CuB,oD;2Bf0+CO,oBAAmB,yBAAnB,EAAmB,iCAAnB,U;YAAV,UAAuC,sB;Yez+CvE,IAAI,kBfy+CgF,Oez+ChF,CAAJ,C;cACI,YAAgB,GAAI,UAAR,GAAmB,YAAnB,GAA0B,GAAI,M;cAD9C,8BAEI,aAAa,eAAI,CAAJ,IAAb,C;cAFJ,gB;;;cAII,IAAI,CAAC,GAAI,UAAT,C;gBAAoB,gB;gCAAA,iCAAM,GAAN,O;oBAAA,qC;yBAAA,mB;gBAAA,Q;;gBAApB,gB;;;;;;YAAA,gB;;;YAJJ,8BAKI,oBAAQ,YAAR,C;YALJ,gB;;;Yfy+CkB,oD;YAAtB,gB;;;Ye1+CA,gBf2+CO,sB;Yel+CP,IAAI,CAAC,SAAU,UAAf,C;cAA0B,gB;8BAAA,iCAAM,SAAN,O;kBAAA,qC;uBAAA,mB;cAAA,Q;;cAA1B,gB;;;;;YATA,W;;YAUJ,W;;;;;;;;;;;;;;EAAA,C;EAXgF,yF;IAAA,yD;qBAAA,gI;UAAA,S;eAAA,Q;;eAAA,uB;IAWhF,C;G;EAdA,qD;IAGuE,OAWrE,OAXqE,SAAS,kDAAT,CAWrE,C;G;EAGF,yC;IAKa,kBADG,sBAAL,SAAK,EAAsB,IAAtB,C;IACH,sB;;Mf2IO,Q;MAAA,6B;MAAhB,OAAgB,cAAhB,C;QAAgB,yB;QAAM,IAAc,Oe3Ib,sBf2ID,C;UAAwB,qBAAO,O;UAAP,uB;;MAC9C,qBAAO,I;;;Ie7IP,yB;EAEJ,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SHvG6B,2BAAgB,WAAhB,C;SACL,2BAAoB,WAApB,C;;;;;"}